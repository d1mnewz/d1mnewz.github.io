C# постійно розвивається, місцями навіть настільки швидко, що не встигаєш оцінити всі нові фічі, які розробники платформи .NET додають з кожною версією. 

<img src="https://tproger2.azureedge.net/wp-content/uploads/2016/11/sharp-min.png"/>

Я хочу розповісти про C# 7.0 та його новинки. 

Але перед цим давайте швидко оцінимо, як розвивався C# з плином часу та версій:

<ul>
<li>C# 1.0 - Managed Code.</li>
<li>C# 2.0 - з'являються Generic колекції.</li>
<li>C# 3.0 - LINQ, методи-розширення, лямбда-вирази, анонімні типи.</li>
<li>C# 4.0 - динамічне програмування, опціональні параметри, приведення Generic`ів до їх базових типів.</li>
<li>C# 5.0 - спрощення асинхронного програмування за допомогою async & await.</li>
<li>C# 6.0 - переписаний з нуля новий компілятор (<a target = "_blank" href = "https://github.com/dotnet/roslyn">Roslyn</a>), інтерполяція 
стрінгів, nameof(), оператор перевірки на null "?" та ще багато-багато іншого.</li>
</ul>

### Розробка C# 7.0.

Очевидно, C# 7.0 теж готує нам кілька серйозних оновлень. Судячи з блогу команди, яка працює над цим проектом, вони приділяють найбільше уваги таким позиціям:
<ul>
<li><b>Робота з даними</b> - підвищення відсотку використання веб сервісів напряму змінює те, як моделюються і виглядають дані. Замість розробки моделей даних у якості окремого модулю програми, їхні визначення стають частинами контрактів веб-сервісів. Це супер-зручно в функціональних мовах програмування (F#!!!), проте додає зайвої складності в ООП. Деякі з новинок C# 7.0 націлені саме на спрощення роботи з зовнішніми даними.</li>
<li><b>Покращення продуктивності</b> - збільшення поширеності мобільних девайсів робить покращення продуктивності все важливішим і важливішим питання. Вже є заплановані деталі C# 7.0, які могли б дозволити оптимізувати продуктивність дещо серйозніше, аніж це було у попередніх версія .NET. </li>

<li><b>Спрощення коду</b> - трошки синтаксичного цукру, нарешті :) Кілька додаткових незначних змін, які зроблять сам процес програмування приємнішим, а код читабельнішим.</li>
</ul> 
Давайте проаналізуємо детальніше кожен з цих пунктів.

<img src = "https://media.giphy.com/media/iEivb6DyFoJJm/giphy-facebook_s.jpg">


### Робота з даними

Об'єктно орієнтовані мови типу C# чи Java показують себе прекрасно в роботі з завчасно визначеним списоком операцій над певним гнучним списоком типів даних. Зазвичай вони змодельовані при використанні інтерфейсу (або базового класу) з уточненнями доступним операцій і потенційно зростаючим числом класів, які представлють ці типи даних. Це означає, що, імплементуючи інтерфес, ми отримуємо клас, який містить в собі реалізацію всіх очікуваних операцій. 

Наприклад, в грі, яка вже встигла стати класикою ООП, класи можуть бути різними типами зброї (меч, лук і т.д.) і операції можуть бути різними діями (атакувати, поремонтувати, модифікувати зброю). В цьому випадку додавання нового типу зброї (лазерного меча з зоряних війн %)) є досить простим: створюємо новий клас, який реалізує інтерфейс "зброї". Проте додавання нової дії (перезарядка наприклад) потребувало б розширення інтерфейсу і модифікування всієї вже існуючої зброї дописуванням в них реалізацію нової дії. І ми до такого звикли. 

Приблизно так це б виглядало:
<img src = "http://joxi.ru/Vm6zNKJCJWEGmZ.png"/>

У функціональному програмуванні типи даних не мають операцій. Замість цього кожна функція реалізує одиничну операцію для кожного типу даних. Це робить додавання нової операції набагато простішим - просто реалізувати нову функцію, але при цьому робить важчим додавання нового типу даних, адже треба буде модифікувати всі існуючі функції. Ми й зараз можемо таке зробити в C#, виглядатиме приблизно ось так:

<img src = "http://joxi.ru/KAxX1pPCOGQvA8.png">

In functional programming, data types do not include operations. Instead, each function implements a single operation for all the data types. This makes it much easier to add a new operation (just define and implement a new function), but much more difficult to add a new data type (modify all existing functions accordingly). While this is already possible in C#, it is much more verbose than it could be.