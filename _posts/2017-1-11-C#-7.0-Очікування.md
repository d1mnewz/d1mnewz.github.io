C# постійно розвивається, місцями навіть настільки швидко, що не встигаєш оцінити всі нові фічі, які розробники платформи .NET додають з кожною версією. 

<img src="https://tproger2.azureedge.net/wp-content/uploads/2016/11/sharp-min.png"/>

Я хочу розповісти про C# 7.0 та його новинки. 

Але перед цим давайте швидко оцінимо, як розвивався C# з плином часу та версій:

<ul>
<li>C# 1.0 - Managed Code.</li>
<li>C# 2.0 - з'являються Generic колекції.</li>
<li>C# 3.0 - LINQ, методи-розширення, лямбда-вирази, анонімні типи.</li>
<li>C# 4.0 - динамічне програмування, опціональні параметри, приведення Generic`ів до їх базових типів.</li>
<li>C# 5.0 - спрощення асинхронного програмування за допомогою async & await.</li>
<li>C# 6.0 - переписаний з нуля новий компілятор (<a target = "_blank" href = "https://github.com/dotnet/roslyn">Roslyn</a>), інтерполяція 
стрінгів, nameof(), оператор перевірки на null "?" та ще багато-багато іншого.</li>
</ul>

### Розробка C# 7.0.

Очевидно, C# 7.0 теж готує нам кілька серйозних оновлень. Судячи з блогу команди, яка працює над цим проектом, вони приділяють найбільше уваги таким позиціям:
<ul>
<li><b>Робота з даними</b> - підвищення відсотку використання веб сервісів напряму змінює те, як моделюються і виглядають дані. Замість розробки моделей даних у якості окремого модулю програми, їхні визначення стають частинами контрактів веб-сервісів. Це супер-зручно в функціональних мовах програмування (F#!!!), проте додає зайвої складності в ООП. Деякі з новинок C# 7.0 націлені саме на спрощення роботи з зовнішніми даними.</li>
<li><b>Покращення продуктивності</b> - збільшення поширеності мобільних девайсів робить покращення продуктивності все важливішим і важливішим питання. Вже є заплановані деталі C# 7.0, які могли б дозволити оптимізувати продуктивність дещо серйозніше, аніж це було у попередніх версія .NET. </li>

<li><b>Спрощення коду</b> - трошки синтаксичного цукру, нарешті :) Кілька додаткових незначних змін, які зроблять сам процес програмування приємнішим, а код читабельнішим.</li>
</ul> 
Давайте проаналізуємо детальніше кожен з цих пунктів.

<img src = "https://media.giphy.com/media/iEivb6DyFoJJm/giphy-facebook_s.jpg">


### Робота з даними

Об'єктно орієнтовані мови типу C# чи Java показують себе прекрасно в роботі з завчасно визначеним списоком операцій над певним гнучним списоком типів даних. Зазвичай вони змодельовані при використанні інтерфейсу (або базового класу) з уточненнями доступним операцій і потенційно зростаючим числом класів, які представлють ці типи даних. Це означає, що, імплементуючи інтерфес, ми отримуємо клас, який містить в собі реалізацію всіх очікуваних операцій. 

Наприклад, в грі, яка вже встигла стати класикою ООП, класи можуть бути різними типами зброї (меч, лук і т.д.) і операції можуть бути різними діями (атакувати, поремонтувати, модифікувати зброю). В цьому випадку додавання нового типу зброї (лазерного меча з зоряних війн %)) є досить простим: створюємо новий клас, який реалізує інтерфейс "зброї". Проте додавання нової дії (перезарядка наприклад) потребувало б розширення інтерфейсу і модифікування всієї вже існуючої зброї дописуванням в них реалізацію нової дії. І ми до такого звикли. 

Приблизно так це б виглядало:

<img src = "http://joxi.ru/Vm6zNKJCJWEGmZ.png"/>

У функціональному програмуванні типи даних не мають операцій. Замість цього кожна функція реалізує одиничну операцію для кожного типу даних. Це робить додавання нової операції набагато простішим - просто реалізувати нову функцію, але при цьому робить важчим додавання нового типу даних, адже треба буде модифікувати всі існуючі функції. Ми й зараз можемо таке зробити в C#, виглядатиме приблизно ось так:

<img src = "http://joxi.ru/KAxX1pPCOGQvA8.png">

От якби ми могли визначити, що це за тип зброї. Це б значно спростило наш код. Ось що і пропонує C# 7.0.
<b>Pattern Matching</b>.
Спробуємо покроково прикрутити це до нашого коду:

<img src = "http://joxi.ru/MAjJ6dPt93GOAe.png"/>

Тепер нам не треба перевіряти тип зброї і присвоювати в його в змінну в двох рядках, адже оператор is тепер дозволяє нам створити нову змінну і відразу присвоїти їй відразу потрібний тип. (Bow bow, Sword sword). 

Цей код можна оптимізувати. Давайте використаємо switch. Це зробить код чистішим, особливо у випадках, коли ми матимемо багато типів зброї:

<img src = "http://joxi.ru/82QMwjnH0agO2d.png"/>

Як мінімум, виглядає гарно. Раніше треба було гратись з розпаковкою/упаковкою, визначенням типу, малювати незрозумілий нікому, окрім Всевишнього, код. 
Гарно ж таки кожен кейс ще виконує спочатку приведення до типу, а потім ще й додаткову перевірку по ігровій логіці, що покращує зовнішній вигляд коду.

<img src = "https://i.imgflip.com/1hferb.jpg"/>

Так, є ще нові штуки, які мають зробити ваш код красивішим - tuples. Вони щось на зразок легкої для компілятора альтернативи анонімним класам. Переважна їхня зона використання буде в функціях, які повертають кілька значень. При цьому ми не будемо використовувати ключове слово out. 

<img src = "http://joxi.ru/a2XDwl8CvkWd2g.png"/>


Ось таким методом ми повертаємо два значення не використовуючи out та не декларуючи новий тип для цих цілей. 
Навіть синтакс виклику подібного метода є доволі інтуїтивно-зрозумілим:

<img src = "http://joxi.ru/p271JZqHqdbBr7.png"/>


Значення, яке повертається, по суті є дуже подібним до Tuple<> класу з .NET фреймворку. Проте тут є кілька важливих нюансів, які роблять різницю:
<ul>
<li>Можна задавати інформативні назви типу weight & count, при цьому в Tuple ми обмежені item1 & item2 і т.д. Це робить код читабельнішим.</li>
<li>Це вже value type, а не reference type. </li>
</ul>

### Покращення продуктивності 

Покращення продуктивності в C# 7.0 переважно сфокусовано на зменшенні кількості даних, які копіюються в пам'яті. 

Локальні функції тепер дозволять декларувати допоміжну функцію всередині інших функцій. Це не тільки зменшить їх область бачення, але й дозволить використовувати змінні, які оголошені в їхній області бачення, без використання додаткової пам'яті стеку або купи. 
Простіше кажучи, ми тепер можемо створити функцію всередині функції(як Ікзібіт) і для її змінних не братимемо додатково пам'ять з купи або стеку. 

<img src = "http://joxi.ru/LmG4wg6CENzP2l.png"/>

І останнє покращення в продуктивності націлене на асинхронні методи. Зараз всі асинхронні методи мають повертати Task<>, яка є reference типом. А тепер ми маємо value type Task<> з одноіменною назвою ValueTask :) 
Якщо асинхронний метод вже має готовий результат, коли його викликають, то це це покращить продуктивність через те, що буде менше змін в пам'яті купи. 
Додатково C# тепер дозволяє мати спеціальні кастомні повертаючі типи для асинхронних методів, що може бути використано в специфічних бібліотеках. 


### Спрощення коду

С# 6.0 презентував підтримку для методів з тілом через лямбда вирази і read-only властивості. В новій версії ми можемо так само робити з властивостями зчитування/запису, конструкторами та деструкторами:

<img src = "http://joxi.ru/8234yW7C7QQdAO.png"/>

Ось цей клас використовує ще одну фічу - викидає ексепшни. Конструктор це зробить у випадку, якщо в нього прийде негативне значення здоров'я. Раніше це було можливим тільки через додатковий рядок, зараз можна прямо через лямбда-вираз.
Ну, лишилась остання - цифрові літерали, їх тепер підтримує C#. Щоб зробити їх трошки більш читабельними використовують "_" у якості розділювача. 

<img src = "http://joxi.ru/EA41ld8H85kKrb.png"/>

Так само можна працювати не лише з бінарними літералами, а й десятковими та шістнадцятковими. 


<b>Висновок</b>? Так, дійсно, пора вже. 

Всі ці фічі досі допрацьовуються. В фінальному релізі вони можуть виглядати трошки по-іншому або й взагалі не бути там. 
В цій статті я намагався покрити найцікавіші з них, це деякий стрибок в майбутнє, в те, як може виглядати C# код через кілька років.
Можливо, когось це зацікавить і захочеться спробувати самому погратись з цим - треба встановити  Visual Studio “15” Preview 4.

На основі <a href = "http://www.dotnetcurry.com/csharp/1286/csharp-7-new-expected-features" target = "_blank">джерела</a>.
